## 042-Variables Containers for everything

## 043-Var

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var

Варианты объявления и вызова var

```js
var container = 5
// undefined
container
// 5

container = "red"
//'red'
container
//'red'

```

```js
// объявление, где забыли указать var
something = 7
7
something
7
```

```js
// множественное объявление в одной строке
var x = 3, y = 5, z = "blue"
// undefined
x
// 3
y
// 5
z
// 'blue'

```

```js
// Обявление переменной без значения
var empty
// undefined
empty
// undefined
```

## 044-Scope

`var` обладает глобальной видимостью.  

Пример.

```js
var color = "purple";

document.querySelector(".left").style.backgroundColor = color;
document.querySelector(".left .color-value").innerHTML = color;

color = "skyblue";

function headingColor() {
    color = "blue";
    document.querySelector(".title").style.color = color;
}

headingColor();
// После первого вызова функции color перезаписывается глобально на blue,
// весь дальнейший код теперь использует color == blue.  

document.querySelector(".right").style.backgroundColor = color;
document.querySelector(".right .color-value").innerHTML = color;

```

Чтобы решить проблему глобальной видимости, были созданы только для локальной видимости `let` и `const`.

## 045-Let

let - это переменная, которая имеет область видимости только внутри текущего вложенного блока.

Пример.

```js
var color = "purple";

document.querySelector(".left").style.backgroundColor = color;
document.querySelector(".left .color-value").innerHTML = color;

color = "skyblue";

function headingColor() {
  // let имеет видимость только внутри функции
  let color = "blue";
  document.querySelector(".title").style.color = color;  
}

headingColor();

document.querySelector(".right").style.backgroundColor = color;
document.querySelector(".right .color-value").innerHTML = color;
```

`let` внутри функции не будет иметь видимости за пределами функции.

```js
let color = "purple";

document.querySelector(".left").style.backgroundColor = color;
document.querySelector(".left .color-value").innerHTML = color;

color = "skyblue";

function headingColor() {
  // let имеет видимость только внутри функции
  let titleColor = "blue";
  document.querySelector(".title").style.color = titleColor;
  // вывести значение в консоль
  console.log("outside:", titleColor);
}

headingColor();

// видимости за пределами фнкуции нет, будет вызвана ошибка
console.log("outside:", titleColor);

// эти строчки не выполняются из-за обнаруженной ошибки
document.querySelector(".right").style.backgroundColor = color;
document.querySelector(".right .color-value").innerHTML = color;
```

Рекомендуется всегда использовать `let`.  
`var` рекомендуется применять только в случае явной необходимости использования переменной с глобальной областью видимости.  

## 046-Const

`const` работает как `let`, но её значение не может меняться.  

## 047-Data types

Javascript относится к языкам с динамической типизацией.

Статическая типизация — так называется типизация в программировании, при которой тип переменной нужно объявлять заранее — на этапе компиляции, до выполнения программы.   
Это противопоставляется динамической типизации, при которой тип переменной определяется во время выполнения программы.  

```js
// String:
let stringDemo = "A string of text.";
console.log("String:", stringDemo);

// Numbers:
let integerDemo = 4;
console.log("Integer:", integerDemo);

let floatDemo = 5.6;
console.log("Floating point number:", floatDemo);

// Boolean:
let booleanDemo = true;
console.log("Boolean value:", booleanDemo);

// Null value (nothing):
let nullDemo = null;
console.log("Null value:", nullDemo);

// Undefined:
let undefinedDemo;
console.log("Undefined:", undefinedDemo);

let undefinedAssignedDemo = undefined;
console.log("Undefined assigned:", undefinedAssignedDemo);

// Object:
const objectDemo = {
  dance: "Mambo",
  number: 5,
};
console.log("Object:", objectDemo);

// Array:
const arrayDemo = ["tango", "foxtrot", "waltz", "rumba", "bolero"];
console.log("Array:", arrayDemo);
```

Чтоб узнать тип переменной, используется выражение `typeof`.  

```js
let stringDemo = "A string of text.";
console.log("String:", typeof stringDemo);

let floatDemo = 5.6;
console.log("Floating point number:", typeof floatDemo);
```

## 048-Assignment vs comparison


```js
let a = 5;
let b = 4;

console.log(`let a: ${a} (${typeof a})`);
// let a: 5 (number)
console.log(`let b: ${b} (${typeof b})`);
// let a: 4 (number)

if (a == b) {
  console.log(`Match! let a and let b are the same value.`);
} else {
  console.error(`No match: let a and let b are NOT same value.`);
}
// No match: let a and let b are NOT same value.
```

== и === для сравнения и учитывания типов значений работают также, как в PHP. То есть 5 и "5" равны если это ==, и не равны, если используется ===.  
Так же как в PHP, работают знаки сравнения: >, <, >=, !=, !== .

## 049-Math operators

Пример вычисления

```js
let a = 5;
let b = 4;
let c = 3.2;

console.log(`let a: ${a} (${typeof a})`);
console.log(`let b: ${b} (${typeof b})`);
console.log(`let c: ${c} (${typeof c})`);

let result = a + b;

console.log("Result: ", result);
// Result: 9
```

Используются все стандартные операторы и математические правила вычислений.  
Две звёздочки ** означают возведение в степень. % - это модуль, получение остатка при делении.  
Также доступен инкремент и декремент: ++a, --a. При этом, как и в PHP, возможно выполнение инкремента и декремента после вызова переменной, которая в выражении ещё продолжает использоваться со старым значением вплоть до следующего выражения, в котором только она и получает новое значение: a++, b--.  
Выражение `5+"4"` работает, как и в PHP, и приводит к конкатенации, а не к математическому сложению: `54`. При этом минус работает нормально, как в математике, конфуз возможен только со знаком плюс.  

---
