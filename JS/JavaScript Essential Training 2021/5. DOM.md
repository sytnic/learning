## 032-Access elements with querySelector methods

Примеры с "нацеливанием на CSS-цели": теги, классы, отдельные элементы.

querySelector

```js
// тег
document.querySelector("main")

// класс
document.querySelector(".maincontent")

// отдельный элемент списка внутри тега main
document.querySelector("main li:last-child")
```

querySelectorAll

```js
// все элементы списка внутри тега main
document.querySelectorAll("main li")

// все элементы списка внутри тега main
document.querySelectorAll("main li").forEach(item => item.style.backgroundColor = "red")

// один элемент списка внутри тега main
document.querySelectorAll("main li:last-child").forEach(item => item.style.backgroundColor = "blue")
```

## 033-Access elements using older methods

Часто используют (старый способ)  

- element.getElementsByClassName()
- element.getElementById()

Примеры

```js
// все элементы с данным классом
document.getElementsByClassName("packprop")

// один элемент с данным набором классов
document.getElementsByClassName("packprop backpack__color")

// элемент с данным id
document.getElementById("everyday")

```

## 035-Modifying element classes

https://developer.mozilla.org/ru/docs/Web/API/Element/className

```js
var elm = document.querySelector("div");

// получение классов
alert(elm.className); //"booble example"

// установление классов
elm.className = "class1 class2 class3";
alert(elm.className); //"class1 class2 class3"
```

Пример

```js
// получить класс
document.querySelector("h1").className

// задать класс
document.querySelector("h1").className = "new-class"
```

Свойство `className` проблематично, когда нужно заменить один класс там, где вы имеете список из нескольких классов.  
Также `className` вызывает проблемы, когда используется в фреймворках, типа React.  

Лучше использовать `classList` свойство.  

https://developer.mozilla.org/ru/docs/Web/API/Element/classList

Пример

```js
// получить класс
document.querySelector("main li:first-child").classList
```

Все классы выбранного элемента будут получены в виде массива, таким образом, каждый класс этого элемента будет выражен одной строкой, что упрощает добавление и удаление различных классов:

    DOMTokenList(2) ['packprop', 'backpack__volume', value: 'packprop backpack__volume']


`classList` обладает удобными методами.

```js
// задать класс, добавить его в конец имеющегося списка классов
document.querySelector("main li:first-child").classList.add("new-class")

// удаляет класс
document.querySelector("main li:first-child").classList.remove("new-class")

// задаёт или удаляет класс (переключает)
document.querySelector("main li:first-child").classList.toggle("new-class")

// замена имеющегося класса на другой
document.querySelector("main li:first-child").classList.replace("packprop", "new-class")

```

## 36-Attributes

https://developer.mozilla.org/ru/docs/Web/API/Element/attributes


Пример

```js
document.querySelector("img").attributes
```

`.attributes` возвращает `NamedNodeMap`, а не массив.

Примеры методов

```js
// поиск атрибута
document.querySelector("img").hasAttribute("src")
// true, если атрибут найден

// получить значение атрибута
document.querySelector("img").getAttribute("src")

// задать атрибут (создать новый или изменить существующий)
document.querySelector("img").setAttribute("alt", "A drawing of a backpack")

// удаление атрибута
document.querySelector("img").removeAttribute("title")

```

Эти методы подходят и для манипулирования классами, т.к. класс воспринимается как обычный атрибут.  

## 37-Inline style

Ссылка в develop.mozilla редиректит на новую статью  
https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style  


Получить все возможные стили, которые можно применить к элементу с указанным классом. Также этот подход помогает узнать, как в верблюжей нотации JS пишутся все стили, применимые к заданному элементу.  

```js
document.querySelector(".site-title").style
// CSSStyleDeclaration {0: 'color', accentColor: '', additiveSymbols: '', alignContent: '', alignItems: '', alignSelf: '', …}
```

Получить имеющийся стиль

```js
document.querySelector(".site-title").style.color
// 'black'
```

Изменить свойство и инлайн-стиль (объявленный в элементе)

```js
document.querySelector(".site-title").style.color = "rebeccapurple"
// 'rebeccapurple'
```



```js
document.querySelector(".site-title").style.backgroundColor = "pink"

```

```js
document.querySelector(".site-title").style
```
Это выражение в самом конце списка выдаёт такое свойство  
`cssText: "color: rebeccapurple; background-color: pink;"`.  
Это означает, что чтобы изменить сразу несколько инлайн-стилей, нужно изменить этот текст, а не задавать стили по одному через `.style.backgroundColor = "pink"`.   

## 039-Add DOM elements

Некторые предыдущие манипуляции поностью заменяли содержимое div'ов. Теперь будет добавлен контент к существующему, вместо полной его замены.   

document.createElement("div")

https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement

ParentNode.append() ведёт на новую статью Element: append() method

https://developer.mozilla.org/en-US/docs/Web/API/Element/append

Пример

`script.js`

```js
// Создаём содержимое
const content = `
  
    <figure class="backpack__image">
      <img src=${everydayPack.image} alt="" />
    </figure>
    <h1 class="backpack__name">${everydayPack.name}</h1>
    <ul class="backpack__features">
      <li class="packprop backpack__volume">Volume:<span> ${
        everydayPack.volume
      }l</span></li>
      ...
      <li class="packprop backpack__lid">Lid status:<span> ${
        everydayPack.lidOpen
      }</span></li>
    </ul>
  
`;

// Хватаем главный div на HTML-странице
const main = document.querySelector(".maincontent");

// Создаём тег <article> с классами, атрибутами и содержимым
const newArticle = document.createElement("article");
newArticle.classList.add("backpack");
newArticle.setAttribute("id", "everyday");
newArticle.innerHTML = content;

// Помещаем <article> после имеющегося содержимого в div "maincontent"
main.append(newArticle);
```

Можно помещать контент до, а не после имеющегося HTML-содержимого:  

Element: prepend() method  
https://developer.mozilla.org/en-US/docs/Web/API/Element/prepend

Существуют многие другие полезные методы:  
- appendChild()
- replaceChild()
- insertBefore()
- insertAdjacentElement()


## 041-Solution Add a new element

`script.js`

```js
/**
 * Add a navigation section to the DOM
 */
const navContent = `
      <li><a href="#">Home</a></li>
      <li><a href="#">About</a></li>
      <li><a href="#">Backpacks</a></li>
      <li><a href="#">Other things</a></li>
      <li><a href="#">Contact</a></li>
`;

// создаём nav с классом, который настроим в css
const mainNav = document.createElement("nav")
mainNav.classList.add("main-navigation");
// создаём ul
const navList = document.createElement("ul")
// в этот ul добавляем контент со списком li
navList.innerHTML = navContent
// берём nav и помещаем в него ul-li
mainNav.append(navList)

// находим на странице элемент с классом siteheader
// и вставлем в него получившийся nav c ul-li
document.querySelector(".siteheader").append(mainNav)
```

---
