## 042-The anatomy of a class

### Instance Attributes

```py
class Dog:
    def __init__(self, name):
        self.name = name
        self.legs = 4
    
    def speak(self):
        print(self.name + ' says: Bark!')

myDog = Dog('Rover')
print(myDog.name)
print(myDog.legs)
# Rover
# 4 - у объекта есть свойство, оно высчитывается в конструкторе

Dog.legs
# AttributeError: type object 'Dog' has no attribute 'legs'
# - у класса нет свойства, оно не задано в классе
```

### Static Attributes

```py
class Dog:
    legs = 4
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(self.name + ' says: Bark!')

myDog = Dog('Rover')
print(myDog.name)
print(myDog.legs)
# Rover
# 4 - у объекта есть свойство, оно высчитывается в конструкторе

Dog.legs
# 4 
# - у класса есть свойство, оно задано в классе

# - перезапись свойства класса
Dog.legs = 3

myDog = Dog('Rover')
print(myDog.name)
print(myDog.legs) # свойство объекта

# Rover
# 3 - свойство объекта, высчитывается в конструкторе

```


```py
class Dog:
    _legs = 4
    def __init__(self, name):
        self.name = name
        
    def getLegs(self):
        return self._legs
    
    def speak(self):
        print(self.name + ' says: Bark!')

myDog = Dog('Rover')
print(myDog.name)
print(myDog.getLegs()) # - метод объекта

# Rover
# 4 - значение из метода объекта getLegs(self), подхватывающее значение свойства класса _legs

```

```py
myDog = Dog('Rover')
myDog._legs = 3  # перезапись или установление значения свойства у объекта
print(myDog.name)
print(myDog.getLegs())  # - метод объекта
print(Dog._legs)        # - свойство класса

# Rover
# 3 - метод объекта getLegs() подхватывает свойство объекта (3)
# 4 - вызов значения свойства _legs напрямую у класса _legs (4) 

```

## 043-Static and instance methods

Static and Instance Methods

```py
import math
# используется для math. функций

class Orientation:
# статическая переменная
    pi = 3.14
    def __init__(self, x_pos, y_pos, degrees):
        self.x_pos = x_pos
        self.y_pos = y_pos
        self.x_dir, self.y_dir = Orientation.getUnitVectorFromDegrees(degrees)
        
# статический метод
    def getUnitVectorFromDegrees(degrees):
        radians = (degrees/180) * Orientation.pi
        return math.sin(radians), -math.cos(radians)

# метод экземпляра   
    def getNextPos(self):
        return self.x_pos + self.x_dir, self.y_pos + self.y_dir
    
myOrientation = Orientation(5, 5, 75)
myOrientation.getNextPos()

# (5.965753859834238, 4.740540018085118)

```

Decorators

```py
class Orientation:
    pi = 3.14
    def __init__(self, x_pos, y_pos, degrees):
        self.x_pos = x_pos
        self.y_pos = y_pos
        self.x_dir, self.y_dir = self.getUnitVectorFromDegrees(degrees)

# декоратор - это аннотация для определения вашей функции  
    @staticmethod
    def getUnitVectorFromDegrees(degrees):
        radians = (degrees/180) * Orientation.pi
        return math.sin(radians), -math.cos(radians)
    
    def getNextPos(self):
        return self.x_pos + self.x_dir, self.y_pos + self.y_dir
    
myOrientation = Orientation(5, 5, 75)
myOrientation.getNextPos()

# (5.965753859834238, 4.740540018085118)
```

## 044-Inheritance

Class Inheritance

```py
class Dog:
    _legs = 4
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' says: Bark!')
    
    def getLegs(self):
        return self._legs

# class Chihuahua расширяет (наследуется от) класса Dog
class Chihuahua(Dog):
    def speak(self):
        print(f'{self.name} says: Yap yap yap!')
        
    def wagTail(self):
        print('Vigorous wagging!')


dog = Chihuahua('Roxy')

# метод speak перезаписан в дочернем классе Chihuahua
dog.speak()
dog.wagTail()
# Roxy says: Yap yap yap!
# Vigorous wagging!

myDog = Dog('Rover')

# метод speak исполняется от имени родительского класса
myDog.speak()
# Rover says: Bark!

```

Extending built-in classes

```py
myList = list()
# list здесь является новым классом

# наследование
class UniqueList(list):
    def append(self, item):
        if item in self:
            return
        super().append(item)
        # super получает доступ к родительскому классу

        
uniqueList = UniqueList()
uniqueList.append(1)
uniqueList.append(1)
uniqueList.append(2)

print(uniqueList)
# [1, 2]

```

Использование super в конструкторе

```py
class UniqueList(list):
    
    def __init__(self):
        # вызов родительского конструктора
        super().__init__()
        # вызов дополнительного действия в этом дочернем конструкторе
        self.someProperty = 'Unique List!'        

    def append(self, item):
        if item in self:
            return
        super().append(item)

        
uniqueList = UniqueList()
uniqueList.append(1)
uniqueList.append(1)
uniqueList.append(2)

print(uniqueList.someProperty)
# Unique List!
```

---